# Практичне заняття №9
## Завдання 1
### Умова
 Напишіть програму, яка читає файл /etc/passwd за допомогою команди getent passwd, щоб дізнатись, які облікові записи визначені на вашому комп’ютері.
 Програма повинна визначити, чи є серед них звичайні користувачі (ідентифікатори UID повинні бути більші за 500 або 1000, залежно від вашого дистрибутива), окрім вас.

### Рішення
Отже, спочатку треба було дізнатися, який ідентифікатор UID використовувати. Я почитала, що на FreeBSD це 1000, але вирішила ще перевірити вручну командою, яка виводить всіх користувачів та їх UID:
```
getent passwd | awk -F: '{print $1, $3}' | sort -k2n
```

Отримала такий вивід:

![image](https://github.com/user-attachments/assets/e08d89d4-84bf-42bd-ad63-896c40b0372c)

Бачимо, що у користувача anastasiia, тобто у мене, UID 1001, це означає, що будемо використовувати 1000.

Програма складається з трьох функцій.
1) get_current_username - отримує ім'я поточного користувача, під яким запущена програма. За допомогою getuid() отримується UID поточного користувача. Далі getpwuid() використовується для отримання структури passwd, з якої зчитується логін користувача (pw_name). Функція повертає ім’я поточного користувача або NULL, якщо отримати ім’я не вдалося.

2) is_regular_user - перевіряє, чи це звичайний користувач і чи не поточний. 
Рядок (один запис користувача з getent passwd) копіюється для безпечного розбору, за допомогою strtok розбивається рядок за символом :.
Зчитуються ім’я користувача та UID. Якщо UID більший або дорівнює 1001 і користувач не є поточним, на екран виводиться інформація про знайденого користувача.

3) main - головна функція програми. Вона викликає команду getent passwd за допомогою popen() і відкриває потік для читання її виводу. Викликає get_current_username() для визначення поточного користувача. Далі зчитує вивід построково (fgets) та для кожного рядка викликає is_regular_user().
Якщо знайдено хоча б одного звичайного користувача (окрім поточного), інформація виводиться, а якщо ні — повідомляється, що таких користувачів не знайдено. В кінці виконується pclose() для закриття потоку.

Результати запуску з root:

![image](https://github.com/user-attachments/assets/042eaf5f-7d56-4c53-a993-dbe326090576)

Та від звичайного користувача:

![image](https://github.com/user-attachments/assets/b6d97a06-cc10-4681-b31a-6720945f446b)

У FreeBSD UID для root це 0.

## Завдання 2
### Умова
Напишіть програму, яка виконує команду cat /etc/shadow від імені адміністратора, хоча запускається від звичайного користувача.
 (Ваша програма повинна робити необхідне, виходячи з того, що конфігурація системи дозволяє отримувати адміністративний доступ за допомогою відповідної команди.)

### Рішення

## Завдання 3
### Умова
Напишіть програму, яка від імені root копіює файл, який вона перед цим створила від імені звичайного користувача. Потім вона повинна помістити копію у домашній каталог звичайного користувача.
 Далі, використовуючи звичайний обліковий запис, програма намагається змінити файл і зберегти зміни. Що відбудеться?
 Після цього програма намагається видалити цей файл за допомогою команди rm. Що відбудеться?

### Рішення

## Завдання 4
### Умова
Напишіть програму, яка по черзі виконує команди whoami та id, щоб перевірити стан облікового запису користувача, від імені якого вона запущена. Є ймовірність, що команда id виведе список різних груп, до яких ви належите. Програма повинна це продемонструвати.

### Рішення
Я написала програму з викоистанням функції system() з бібліотеки stdlib.h, яка дозволяє нам виконувати системні команди. В цю функцію я по черзі передала необхідні команди, а також зробила перевірку, чи коректно виконалась команда. Команда whoami в UNIX-подібних системах використовується для відображення імені поточного користувача, а команда id використовується для отримання інформації про користувача, а саме вона показує ім'я користувача, його UID (User ID), ім'я групи, GID (Group ID), та списки додаткових груп, до яких користувач належить. 
В результаті виконання своєї програми з правами root я отримала такий результат:

![image](https://github.com/user-attachments/assets/108a0aea-db3e-4900-bd6d-7a1d73b2d1a3)

А якщо запустити від імені звичайного користувача, то отримаємо:

![image](https://github.com/user-attachments/assets/707a6f16-dc80-42ff-97a6-b6ff43457b70)

## Завдання 5
### Умова
Напишіть програму, яка створює тимчасовий файл від імені звичайного користувача. Потім від імені суперкористувача використовує команди chown і chmod, щоб змінити тип володіння та права доступу.
 Програма повинна визначити, в яких випадках вона може виконувати читання та запис файлу, використовуючи свій обліковий запис.


### Рішення

## Завдання 6
### Умова
 Напишіть програму, яка виконує команду ls -l, щоб переглянути власника і права доступу до файлів у своєму домашньому каталозі, в /usr/bin та в /etc.
 Продемонструйте, як ваша програма намагається обійти різні власники та права доступу користувачів, а також здійснює спроби читання, запису та виконання цих файлів.

### Рішення

## Індивідуальне завдання
### Умова
Дослідіть ситуацію, коли користувач може змінити файл, хоча не є його власником. Наведіть можливі сценарії та протестуйте їх.

### Рішення
Сценарії, де користувач не є власником, але може змінити файл:
1) Групові права на запис
Це перший варіант такого чітерства. 
Від рута я створила тестовий файл командою:
```
touch test.txt
```

Далі я виконала такі команди:
```
chgrp 1001 test.txt     
chmod 664 test.txt
```

де 1001 - це група, до якої належить користувач anastasiia, а дізналась я це за допомогою команди.

```
id anastasiia
```
оскільки працювала від рута.

Друга команда встановлює права доступу, числова команда 664 в розшифровці матиме вигляд: -rw-rw-r--, що означає, що власник може читати і писати, група може читати і писати, інші користувачі - лише читати.

Далі я залогінилась як anastasiia, та виконала команду:
```
echo "changes" > test.txt
```

Тепер файл test має такий вміст:

![image](https://github.com/user-attachments/assets/d399ceee-c411-42dd-84f7-f7f419d07820)

2) ACL - доступ, який доступний у FreeBSD.
ACL (Access Control List) — це розширена система прав доступу до файлів і каталогів, яка доповнює класичну модель UNIX-права (user/group/others).

З рута я створила файл test2.txt та виконала такі команди:

```
setfacl -m u:anastasiia:rw test2.txt
```

З першого разу це не вдалося, бо за замовчуванням у мене був вимкнений ACL, це я дізналась за допомогою команди:
```
mount
```

Тому я перемонтувала файлову систему з ACL командою:

```
mount -u -o acls /
```

Далі я залогінилась як anastasiia, та виконала команду:

```
echo "ACL access" > test2.txt
```

В результаті файл було змінено:

![image](https://github.com/user-attachments/assets/e9b92f80-9e33-41a9-bed4-bfcca0a7e8cc)

3) Каталог з правом на запис та sticky bit
Далі алгоритм тестування випадків буде аналогчний, тому обійдемось теорією.
Умови, щоб цей варіан спрацював:
- Файл розміщений у каталозі з дозволом на запис.
- Sticky bit встановлено (наприклад /tmp).

Тепер можна змінювати вміст існуючих файлів, якщо є відповідні права.
Демонстраційний код:

```
# У каталозі /tmp
cd /tmp
touch file_by_root
chmod 666 file_by_root         # -rw-rw-rw-

# Як звичайний користувач:
echo "новий вміст" > /tmp/file_by_root  # Успішно, якщо файл доступний на запис

```

4) Власник каталогу має дозвіл на запис, а файл — world-writable.
Умови:
- Каталог доступний на запис для користувача.
- Файл має права 666 (усі можуть писати).
- Користувач може змінити вміст, але не може змінити права чи власника.

Демонстраційний код:

```
# В каталозі /tmp
touch /tmp/public_file
chmod 666 /tmp/public_file

# Як звичайний користувач:
echo "тест" > /tmp/public_file   # Працює
```

