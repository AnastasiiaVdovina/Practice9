# Практичне заняття №9
## Завдання 1
### Умова
 Напишіть програму, яка читає файл /etc/passwd за допомогою команди getent passwd, щоб дізнатись, які облікові записи визначені на вашому комп’ютері.
 Програма повинна визначити, чи є серед них звичайні користувачі (ідентифікатори UID повинні бути більші за 500 або 1000, залежно від вашого дистрибутива), окрім вас.

### Рішення
Отже, спочатку треба було дізнатися, який ідентифікатор UID використовувати. Я почитала, що на FreeBSD це 1000, але вирішила ще перевірити вручну командою, яка виводить всіх користувачів та їх UID:
```
getent passwd | awk -F: '{print $1, $3}' | sort -k2n
```

Отримала такий вивід:

![image](https://github.com/user-attachments/assets/e08d89d4-84bf-42bd-ad63-896c40b0372c)

Бачимо, що у користувача anastasiia, тобто у мене, UID 1001, це означає, що будемо використовувати 1000.

Програма складається з трьох функцій.
1) get_current_username - отримує ім'я поточного користувача, під яким запущена програма. За допомогою getuid() отримується UID поточного користувача. Далі getpwuid() використовується для отримання структури passwd, з якої зчитується логін користувача (pw_name). Функція повертає ім’я поточного користувача або NULL, якщо отримати ім’я не вдалося.

2) is_regular_user - перевіряє, чи це звичайний користувач і чи не поточний. 
Рядок (один запис користувача з getent passwd) копіюється для безпечного розбору, за допомогою strtok розбивається рядок за символом :.
Зчитуються ім’я користувача та UID. Якщо UID більший або дорівнює 1001 і користувач не є поточним, на екран виводиться інформація про знайденого користувача.

3) main - головна функція програми. Вона викликає команду getent passwd за допомогою popen() і відкриває потік для читання її виводу. Викликає get_current_username() для визначення поточного користувача. Далі зчитує вивід построково (fgets) та для кожного рядка викликає is_regular_user().
Якщо знайдено хоча б одного звичайного користувача (окрім поточного), інформація виводиться, а якщо ні — повідомляється, що таких користувачів не знайдено. В кінці виконується pclose() для закриття потоку.

Результати запуску з root:

![image](https://github.com/user-attachments/assets/042eaf5f-7d56-4c53-a993-dbe326090576)

Та від звичайного користувача:

![image](https://github.com/user-attachments/assets/b6d97a06-cc10-4681-b31a-6720945f446b)

У FreeBSD UID для root це 0.

## Завдання 2
### Умова
Напишіть програму, яка виконує команду cat /etc/shadow від імені адміністратора, хоча запускається від звичайного користувача.
 (Ваша програма повинна робити необхідне, виходячи з того, що конфігурація системи дозволяє отримувати адміністративний доступ за допомогою відповідної команди.)

### Рішення

## Завдання 3
### Умова
Напишіть програму, яка від імені root копіює файл, який вона перед цим створила від імені звичайного користувача. Потім вона повинна помістити копію у домашній каталог звичайного користувача.
 Далі, використовуючи звичайний обліковий запис, програма намагається змінити файл і зберегти зміни. Що відбудеться?
 Після цього програма намагається видалити цей файл за допомогою команди rm. Що відбудеться?

### Рішення

## Завдання 4
### Умова
Напишіть програму, яка по черзі виконує команди whoami та id, щоб перевірити стан облікового запису користувача, від імені якого вона запущена. Є ймовірність, що команда id виведе список різних груп, до яких ви належите. Програма повинна це продемонструвати.

### Рішення
Я написала програму з викоистанням функції system() з бібліотеки stdlib.h, яка дозволяє нам виконувати системні команди. В цю функцію я по черзі передала необхідні команди, а також зробила перевірку, чи коректно виконалась команда. Команда whoami в UNIX-подібних системах використовується для відображення імені поточного користувача, а команда id використовується для отримання інформації про користувача, а саме вона показує ім'я користувача, його UID (User ID), ім'я групи, GID (Group ID), та списки додаткових груп, до яких користувач належить. 
В результаті виконання своєї програми з правами root я отримала такий результат:

![image](https://github.com/user-attachments/assets/108a0aea-db3e-4900-bd6d-7a1d73b2d1a3)

А якщо запустити від імені звичайного користувача, то отримаємо:

![image](https://github.com/user-attachments/assets/707a6f16-dc80-42ff-97a6-b6ff43457b70)

## Завдання 5
### Умова
Напишіть програму, яка створює тимчасовий файл від імені звичайного користувача. Потім від імені суперкористувача використовує команди chown і chmod, щоб змінити тип володіння та права доступу.
 Програма повинна визначити, в яких випадках вона може виконувати читання та запис файлу, використовуючи свій обліковий запис.


### Рішення
Спочатку програма створює від рута тимчасовий файл у директорії /tmp за допомогою функції mkstemp(), яка генерує унікальне ім’я файлу на основі шаблону з послідовністю XXXXXX.
Після успішного створення файл закривається, щоб з ним могли працювати інші процеси. Далі програма отримує інформацію про користувача anastasiia за допомогою функції getpwnam(), щоб дізнатися його ідентифікатори користувача (UID) та групи (GID).
Використовуючи ці дані, від імені суперкористувача програма змінює власника створеного тимчасового файлу на anastasiia через виклик chown(), а також встановлює права доступу до файлу на 0644 за допомогою chmod(), що дає право власнику читати і писати файл, а іншим користувачам — лише читати. 
Після цього програма створює дочірній процес через fork(). У дочірньому процесі відбувається пониження прав: встановлюється груповий та користувацький ідентифікатор на значення користувача anastasiia за допомогою setgid() і setuid(), що гарантує, що подальші дії виконуються саме з його правами. 
Дочірній процес намагається відкрити тимчасовий файл у режимі читання та запису ("r+") через fopen().
Якщо відкриття файлу вдається, програма виводить повідомлення про успішний доступ, інакше повідомляє про помилку з причиною. Після перевірки дочірній процес завершується, а батьківський процес чекає на його завершення через waitpid(). На завершення файл видаляється за допомогою unlink(), щоб не залишати тимчасові сліди.
Все це костильно супроводжується printf, аби бути впевненими, що програма працює як треба.

Результат:

![image](https://github.com/user-attachments/assets/7e2559fd-044d-4faa-b109-a669d6e1e2c9)


## Завдання 6
### Умова
 Напишіть програму, яка виконує команду ls -l, щоб переглянути власника і права доступу до файлів у своєму домашньому каталозі, в /usr/bin та в /etc.
 Продемонструйте, як ваша програма намагається обійти різні власники та права доступу користувачів, а також здійснює спроби читання, запису та виконання цих файлів.

### Рішення
Програма складається з трьох функцій: main, process_directory і check_permissions.
1) Функція check_permissions приймає повний шлях до файлу і виконує три послідовні перевірки прав доступу за допомогою системного виклику access. Вона виводить повідомлення про те, чи дозволено читання, запис або виконання файлу відповідно. Ця функція не змінює жодних властивостей файлу, а лише інформує про поточні права, бо запускати програми або записувати в них щось було б небезпечно.
2) Функція process_directory приймає шлях до каталогу, намагається відкрити його за допомогою opendir і, у разі успіху, спочатку виводить вміст каталогу за допомогою ls -l, що надає користувачу візуальне уявлення про файли та їхні права. Далі програма за допомогою циклу readdir перебирає усі файли і підкаталоги каталогу, пропускаючи спеціальні записи . і ... Для кожного файлу вона формує коректний абсолютний шлях, гарантуючи, що між шляхом каталогу і ім’ям файлу буде вставлено символ /(бо з цим я сиділа годину, і думала чому no such file or directory..). Отриманий повний шлях передається у функцію test_file_access для перевірки прав.
3) У функції main визначено масив директорій, які потрібно проаналізувати: домашній каталог (отриманий через getenv("HOME")), /usr/bin та /etc. Для кожної з цих директорій послідовно викликається функція process_directory. Таким чином, програма систематично і наглядно демонструє, які операції доступні над файлами у найважливіших системних і користувацьких каталогах.

Програму краще запускати з можливістю листати:
```
./task6 | less
```
Результати:

![image](https://github.com/user-attachments/assets/fa20e701-0c6f-405d-914c-67160c7ec8ee)

![image](https://github.com/user-attachments/assets/64d6848a-ba20-4f46-85ba-0ea19180da32)

## Індивідуальне завдання
### Умова
Дослідіть ситуацію, коли користувач може змінити файл, хоча не є його власником. Наведіть можливі сценарії та протестуйте їх.

### Рішення
Сценарії, де користувач не є власником, але може змінити файл:
1) Групові права на запис
Це перший варіант такого чітерства. 
Від рута я створила тестовий файл командою:
```
touch test.txt
```

Далі я виконала такі команди:
```
chgrp 1001 test.txt     
chmod 664 test.txt
```

де 1001 - це група, до якої належить користувач anastasiia, а дізналась я це за допомогою команди.

```
id anastasiia
```
оскільки працювала від рута.

Друга команда встановлює права доступу, числова команда 664 в розшифровці матиме вигляд: -rw-rw-r--, що означає, що власник може читати і писати, група може читати і писати, інші користувачі - лише читати.

Далі я залогінилась як anastasiia, та виконала команду:
```
echo "changes" > test.txt
```

Тепер файл test має такий вміст:

![image](https://github.com/user-attachments/assets/d399ceee-c411-42dd-84f7-f7f419d07820)

2) ACL - доступ, який доступний у FreeBSD.
ACL (Access Control List) — це розширена система прав доступу до файлів і каталогів, яка доповнює класичну модель UNIX-права (user/group/others).

З рута я створила файл test2.txt та виконала такі команди:

```
setfacl -m u:anastasiia:rw test2.txt
```

З першого разу це не вдалося, бо за замовчуванням у мене був вимкнений ACL, це я дізналась за допомогою команди:
```
mount
```

Тому я перемонтувала файлову систему з ACL командою:

```
mount -u -o acls /
```

Далі я залогінилась як anastasiia, та виконала команду:

```
echo "ACL access" > test2.txt
```

В результаті файл було змінено:

![image](https://github.com/user-attachments/assets/e9b92f80-9e33-41a9-bed4-bfcca0a7e8cc)

3) Каталог з правом на запис та sticky bit
Далі алгоритм тестування випадків буде аналогчний, тому обійдемось теорією.
Умови, щоб цей варіан спрацював:
- Файл розміщений у каталозі з дозволом на запис.
- Sticky bit встановлено (наприклад /tmp).

Тепер можна змінювати вміст існуючих файлів, якщо є відповідні права.
Демонстраційний код:

```
# У каталозі /tmp
cd /tmp
touch file_by_root
chmod 666 file_by_root         # -rw-rw-rw-

# Як звичайний користувач:
echo "новий вміст" > /tmp/file_by_root  # Успішно, якщо файл доступний на запис

```

4) Власник каталогу має дозвіл на запис, а файл — world-writable.
Умови:
- Каталог доступний на запис для користувача.
- Файл має права 666 (усі можуть писати).
- Користувач може змінити вміст, але не може змінити права чи власника.

Демонстраційний код:

```
# В каталозі /tmp
touch /tmp/public_file
chmod 666 /tmp/public_file

# Як звичайний користувач:
echo "тест" > /tmp/public_file   # Працює
```

